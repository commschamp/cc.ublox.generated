// Generated by commsdsl2comms v6.1.0

/// @file
/// @brief Contains definition of <b>"CfgValPairSimple"</b> field.

#pragma once

#include <tuple>
#include "cc_ublox/field/CfgValKeyId.h"
#include "cc_ublox/field/CfgValL.h"
#include "cc_ublox/field/CfgValPairSimpleCommon.h"
#include "cc_ublox/field/CfgValU1.h"
#include "cc_ublox/field/CfgValU2.h"
#include "cc_ublox/field/CfgValU4.h"
#include "cc_ublox/field/CfgValU8.h"
#include "cc_ublox/field/FieldBase.h"
#include "cc_ublox/options/DefaultOptions.h"
#include "comms/Assert.h"
#include "comms/CompileControl.h"
#include "comms/field/Bundle.h"
#include "comms/field/Variant.h"
#include "comms/options.h"

#include "comms/cast.h"

namespace cc_ublox
{

namespace field
{

/// @brief Scope for all the member fields of
///     @ref CfgValPairSimple field.
/// @tparam TOpt Protocol options.
template <typename TOpt = cc_ublox::options::DefaultOptions>
struct CfgValPairSimpleMembers
{
    /// @brief Definition of <b>"Key"</b> field.
    class Key : public
        cc_ublox::field::CfgValKeyId<
            TOpt
        >
    {
        using Base =
            cc_ublox::field::CfgValKeyId<
                TOpt
            >;
    public:
        /// @brief Name of the field.
        static const char* name()
        {
            return cc_ublox::field::CfgValPairSimpleMembersCommon::KeyCommon::name();
        }
    };

    /// @brief Scope for all the member fields of
    ///     @ref Val field.
    struct ValMembers
    {
        /// @brief Definition of <b>"L"</b> field.
        class L : public
            cc_ublox::field::CfgValL<
                TOpt
            >
        {
            using Base =
                cc_ublox::field::CfgValL<
                    TOpt
                >;
        public:
            /// @brief Name of the field.
            static const char* name()
            {
                return cc_ublox::field::CfgValPairSimpleMembersCommon::ValMembersCommon::LCommon::name();
            }
        };

        /// @brief Definition of <b>"U1"</b> field.
        class U1 : public
            cc_ublox::field::CfgValU1<
                TOpt
            >
        {
            using Base =
                cc_ublox::field::CfgValU1<
                    TOpt
                >;
        public:
            /// @brief Name of the field.
            static const char* name()
            {
                return cc_ublox::field::CfgValPairSimpleMembersCommon::ValMembersCommon::U1Common::name();
            }
        };

        /// @brief Definition of <b>"U2"</b> field.
        class U2 : public
            cc_ublox::field::CfgValU2<
                TOpt
            >
        {
            using Base =
                cc_ublox::field::CfgValU2<
                    TOpt
                >;
        public:
            /// @brief Name of the field.
            static const char* name()
            {
                return cc_ublox::field::CfgValPairSimpleMembersCommon::ValMembersCommon::U2Common::name();
            }
        };

        /// @brief Definition of <b>"U4"</b> field.
        class U4 : public
            cc_ublox::field::CfgValU4<
                TOpt
            >
        {
            using Base =
                cc_ublox::field::CfgValU4<
                    TOpt
                >;
        public:
            /// @brief Name of the field.
            static const char* name()
            {
                return cc_ublox::field::CfgValPairSimpleMembersCommon::ValMembersCommon::U4Common::name();
            }
        };

        /// @brief Definition of <b>"U8"</b> field.
        class U8 : public
            cc_ublox::field::CfgValU8<
                TOpt
            >
        {
            using Base =
                cc_ublox::field::CfgValU8<
                    TOpt
                >;
        public:
            /// @brief Name of the field.
            static const char* name()
            {
                return cc_ublox::field::CfgValPairSimpleMembersCommon::ValMembersCommon::U8Common::name();
            }
        };

        /// @brief All members bundled in @b std::tuple.
        using All =
            std::tuple<
               L,
               U1,
               U2,
               U4,
               U8
            >;
    };

    /// @brief Definition of <b>"Val"</b> field.
    class Val : public
        comms::field::Variant<
            cc_ublox::field::FieldBase<>,
            typename ValMembers::All,
            comms::option::def::HasCustomWrite,
            comms::option::def::HasCustomRefresh,
            comms::option::def::VariantHasCustomResetOnDestruct,
            comms::option::def::HasVersionDependentMembers<false>
        >
    {
        using Base =
            comms::field::Variant<
                cc_ublox::field::FieldBase<>,
                typename ValMembers::All,
                comms::option::def::HasCustomWrite,
                comms::option::def::HasCustomRefresh,
                comms::option::def::VariantHasCustomResetOnDestruct,
                comms::option::def::HasVersionDependentMembers<false>
            >;
    public:
        /// @brief Default constructor.
        Val() = default;

        /// @brief Destructor
        ~Val()
        {
            reset();
        }

        /// @brief Allow access to internal fields.
        /// @details See definition of @b COMMS_VARIANT_MEMBERS_NAMES macro
        ///     related to @b comms::field::Variant class from COMMS library
        ///     for details.
        ///
        ///     The generated values, types and access functions are:
        ///     @li @b FieldIdx_l index, @b Field_l type,
        ///         @b initField_l(), @b deinitField_l() and @b accessField_l() access functions -
        ///         for cc_ublox::field::CfgValPairSimpleMembers::ValMembers::L member field.
        ///     @li @b FieldIdx_u1 index, @b Field_u1 type,
        ///         @b initField_u1(), @b deinitField_u1() and @b accessField_u1() access functions -
        ///         for cc_ublox::field::CfgValPairSimpleMembers::ValMembers::U1 member field.
        ///     @li @b FieldIdx_u2 index, @b Field_u2 type,
        ///         @b initField_u2(), @b deinitField_u2() and @b accessField_u2() access functions -
        ///         for cc_ublox::field::CfgValPairSimpleMembers::ValMembers::U2 member field.
        ///     @li @b FieldIdx_u4 index, @b Field_u4 type,
        ///         @b initField_u4(), @b deinitField_u4() and @b accessField_u4() access functions -
        ///         for cc_ublox::field::CfgValPairSimpleMembers::ValMembers::U4 member field.
        ///     @li @b FieldIdx_u8 index, @b Field_u8 type,
        ///         @b initField_u8(), @b deinitField_u8() and @b accessField_u8() access functions -
        ///         for cc_ublox::field::CfgValPairSimpleMembers::ValMembers::U8 member field.
        COMMS_VARIANT_MEMBERS_NAMES(
            l,
            u1,
            u2,
            u4,
            u8
        );

        /// @brief Copy constructor.
        Val(const Val& other) :
            Base()
        {
            *this = other;
        }

        /// @brief Move constructor.
        Val(Val&& other) : 
            Base()
        {
            *this = std::move(other);
        }

        /// @brief Copy assignment operator.
        Val& operator=(const Val& other)
        {
            if (this == &other) {
                return *this;
            }

            reset();

            if (!other.currentFieldValid()) {
                return *this;
            }

            switch (other.currentField()) {
                case FieldIdx_l: initField_l() = other.accessField_l(); return *this;
                case FieldIdx_u1: initField_u1() = other.accessField_u1(); return *this;
                case FieldIdx_u2: initField_u2() = other.accessField_u2(); return *this;
                case FieldIdx_u4: initField_u4() = other.accessField_u4(); return *this;
                case FieldIdx_u8: initField_u8() = other.accessField_u8(); return *this;
                default: break;
            }

            COMMS_ASSERT(false); // Should not be reached
            return *this;
        }

        /// @brief Move assignement operator.
        Val& operator=(Val&& other)
        {    if (this == &other) {
                return *this;
            }

            reset();

            if (!other.currentFieldValid()) {
                return *this;
            }

            switch (other.currentField()) {
                case FieldIdx_l: initField_l() = std::move(other.accessField_l()); return *this;
                case FieldIdx_u1: initField_u1() = std::move(other.accessField_u1()); return *this;
                case FieldIdx_u2: initField_u2() = std::move(other.accessField_u2()); return *this;
                case FieldIdx_u4: initField_u4() = std::move(other.accessField_u4()); return *this;
                case FieldIdx_u8: initField_u8() = std::move(other.accessField_u8()); return *this;
                default: break;
            }

            COMMS_ASSERT(false); // Should not be reached
            return *this;
        }

        /// @brief Equality comparison operator.
        bool operator==(const Val& other) const
        {
            if (this == &other) {
                return true;
            }

            if (Base::currentFieldValid() != other.currentFieldValid()) {
                return false;
            }

            if (!Base::currentFieldValid()) {

                return true;
            }

            if (Base::currentField() != other.currentField()) {

                return false;
            }

            switch(Base::currentField()) {
                case FieldIdx_l: return accessField_l() == other.accessField_l();
                case FieldIdx_u1: return accessField_u1() == other.accessField_u1();
                case FieldIdx_u2: return accessField_u2() == other.accessField_u2();
                case FieldIdx_u4: return accessField_u4() == other.accessField_u4();
                case FieldIdx_u8: return accessField_u8() == other.accessField_u8();
                default: break;
            }

            COMMS_ASSERT(false); // Should not be reached
            return false;
        }

        /// @brief Inequality comparison operator.
        bool operator!=(const Val& other) const
        {
            return !(*this == other);
        }

        /// @brief Order comparison operator.
        bool operator<(const Val& other) const
        {
            if (!Base::currentFieldValid()) {
                return (!other.currentFieldValid());
            }

            if (!other.currentFieldValid()) {
                return false;
            }

            if (Base::currentField() < other.currentField()) {
                return true;
            }

            if (Base::currentField() != other.currentField()) {
                return false;
            }

            if (this == &other) {
                return false;
            }
            switch(Base::currentField()) {
                case FieldIdx_l: return accessField_l() < other.accessField_l();
                case FieldIdx_u1: return accessField_u1() < other.accessField_u1();
                case FieldIdx_u2: return accessField_u2() < other.accessField_u2();
                case FieldIdx_u4: return accessField_u4() < other.accessField_u4();
                case FieldIdx_u8: return accessField_u8() < other.accessField_u8();
                default: break;
            }

            COMMS_ASSERT(false); // Should not be reached
            return false;
        }

        /// @brief Optimized currentFieldExec functionality.
        /// @details Replaces the currentFieldExec() member function defined
        ///    by @b comms::field::Variant.
        template <typename TFunc>
        void currentFieldExec(TFunc&& func) 
        {
            switch (Base::currentField()) {
                case FieldIdx_l:
                    memFieldDispatch<FieldIdx_l>(accessField_l(), std::forward<TFunc>(func));
                    break;
                case FieldIdx_u1:
                    memFieldDispatch<FieldIdx_u1>(accessField_u1(), std::forward<TFunc>(func));
                    break;
                case FieldIdx_u2:
                    memFieldDispatch<FieldIdx_u2>(accessField_u2(), std::forward<TFunc>(func));
                    break;
                case FieldIdx_u4:
                    memFieldDispatch<FieldIdx_u4>(accessField_u4(), std::forward<TFunc>(func));
                    break;
                case FieldIdx_u8:
                    memFieldDispatch<FieldIdx_u8>(accessField_u8(), std::forward<TFunc>(func));
                    break;
                default:
                    static constexpr bool Invalid_field_execution = false;
                    static_cast<void>(Invalid_field_execution);
                    COMMS_ASSERT(Invalid_field_execution);
                    break;
            }
        }

        /// @brief The same as currentFieldExec() 
        /// @details Generated for backward comatibility, can be removed in the future.
        template <typename TFunc>
        void currFieldExec(TFunc&& func) 
        {
            currentFieldExec(std::forward<TFunc>(func));
        }

        /// @brief Optimized currentFieldExec functionality (const variant).
        /// @details Replaces the currentFieldExec() member function defined
        ///    by @b comms::field::Variant.
        template <typename TFunc>
        void currentFieldExec(TFunc&& func) const
        {
            switch (Base::currentField()) {
                case FieldIdx_l:
                    memFieldDispatch<FieldIdx_l>(accessField_l(), std::forward<TFunc>(func));
                    break;
                case FieldIdx_u1:
                    memFieldDispatch<FieldIdx_u1>(accessField_u1(), std::forward<TFunc>(func));
                    break;
                case FieldIdx_u2:
                    memFieldDispatch<FieldIdx_u2>(accessField_u2(), std::forward<TFunc>(func));
                    break;
                case FieldIdx_u4:
                    memFieldDispatch<FieldIdx_u4>(accessField_u4(), std::forward<TFunc>(func));
                    break;
                case FieldIdx_u8:
                    memFieldDispatch<FieldIdx_u8>(accessField_u8(), std::forward<TFunc>(func));
                    break;
                default:
                    static constexpr bool Invalid_field_execution = false;
                    static_cast<void>(Invalid_field_execution);
                    COMMS_ASSERT(Invalid_field_execution);
                    break;
            }
        }

        /// @brief The same as currentFieldExec()  (const variant)
        /// @details Generated for backward comatibility, can be removed in the future.
        template <typename TFunc>
        void currFieldExec(TFunc&& func) const
        {
            currentFieldExec(std::forward<TFunc>(func));
        }

        /// @brief Optimized runtime selection field functionality.
        /// @details Replaces the selectField() member function defined
        ///    by @b comms::field::Variant.
        void selectField(std::size_t idx)
        {
            if (Base::currentField() == idx) {
                return;
            }

            reset();
            switch (Base::currentField()) {
                case FieldIdx_l: initField_l(); return;
                case FieldIdx_u1: initField_u1(); return;
                case FieldIdx_u2: initField_u2(); return;
                case FieldIdx_u4: initField_u4(); return;
                case FieldIdx_u8: initField_u8(); return;
                default: break;
            }
            COMMS_ASSERT(false); // Should not be reached
        }

        /// @brief Optimized reset functionality.
        /// @details Replaces the reset() member function defined
        ///    by @b comms::field::Variant.
        void reset()
        {
            if (!Base::currentFieldValid()) {
                return;
            }

            switch (Base::currentField()) {
                case FieldIdx_l: deinitField_l(); return;
                case FieldIdx_u1: deinitField_u1(); return;
                case FieldIdx_u2: deinitField_u2(); return;
                case FieldIdx_u4: deinitField_u4(); return;
                case FieldIdx_u8: deinitField_u8(); return;
                default: break;
            }
            COMMS_ASSERT(false); // Should not be reached
        }

        /// @brief Optimized check ability to write.
        /// @details Replaces the canWrite() member function defined
        ///    by @b comms::field::Variant.
        bool canWrite() const
        {
            if (!Base::currentFieldValid()) {
                return true;
            }

            switch (Base::currentField()) {
                case FieldIdx_l: return accessField_l().canWrite();
                case FieldIdx_u1: return accessField_u1().canWrite();
                case FieldIdx_u2: return accessField_u2().canWrite();
                case FieldIdx_u4: return accessField_u4().canWrite();
                case FieldIdx_u8: return accessField_u8().canWrite();
                default: break;
            }
            COMMS_ASSERT(false); // Should not be reached
            return false;
        }

        /// @brief Name of the field.
        static const char* name()
        {
            return cc_ublox::field::CfgValPairSimpleMembersCommon::ValCommon::name();
        }

        /// @brief Generated write functionality.
        template <typename TIter>
        comms::ErrorStatus write(TIter& iter, std::size_t len) const
        {
            switch (Base::currentField()) {
                case FieldIdx_l: return accessField_l().write(iter, len);
                case FieldIdx_u1: return accessField_u1().write(iter, len);
                case FieldIdx_u2: return accessField_u2().write(iter, len);
                case FieldIdx_u4: return accessField_u4().write(iter, len);
                case FieldIdx_u8: return accessField_u8().write(iter, len);
                default: break;
            }

            return comms::ErrorStatus::Success;
        }

        /// @brief Generated refresh functionality.
        bool refresh()
        {
            switch (Base::currentField()) {
                case FieldIdx_l: return accessField_l().refresh();
                case FieldIdx_u1: return accessField_u1().refresh();
                case FieldIdx_u2: return accessField_u2().refresh();
                case FieldIdx_u4: return accessField_u4().refresh();
                case FieldIdx_u8: return accessField_u8().refresh();
                default: break;
            }

            return false;
        }

        /// @brief Generated length functionality.
        std::size_t length() const
        {
            switch (Base::currentField()) {
                case FieldIdx_l: return accessField_l().length();
                case FieldIdx_u1: return accessField_u1().length();
                case FieldIdx_u2: return accessField_u2().length();
                case FieldIdx_u4: return accessField_u4().length();
                case FieldIdx_u8: return accessField_u8().length();
                default: break;
            }

            return 0U;
        }

        /// @brief Generated validity check functionality.
        bool valid() const
        {
            switch (Base::currentField()) {
                case FieldIdx_l: return accessField_l().valid();
                case FieldIdx_u1: return accessField_u1().valid();
                case FieldIdx_u2: return accessField_u2().valid();
                case FieldIdx_u4: return accessField_u4().valid();
                case FieldIdx_u8: return accessField_u8().valid();
                default: break;
            }

            return false;
        }

    private:
        template <std::size_t TIdx, typename TField, typename TFunc>
        static void memFieldDispatch(TField&& f, TFunc&& func)
        {
            #ifdef _MSC_VER
                func.operator()<TIdx>(std::forward<TField>(f)); // VS compiler
            #else // #ifdef _MSC_VER
                func.template operator()<TIdx>(std::forward<TField>(f)); // All other compilers
            #endif // #ifdef _MSC_VER
        }
    };

    /// @brief All members bundled in @b std::tuple.
    using All =
        std::tuple<
           Key,
           Val
        >;
};

/// @brief Definition of <b>"CfgValPairSimple"</b> field.
/// @details
///     The CfgValPair definition may be too extensive and too complex
///     for some applications. This field may be a simpler replacement.
///     It also requires custom various custom operations.
/// @tparam TOpt Protocol options.
/// @tparam TExtraOpts Extra options.
template <typename TOpt = cc_ublox::options::DefaultOptions, typename... TExtraOpts>
class CfgValPairSimple : public
    comms::field::Bundle<
        cc_ublox::field::FieldBase<>,
        typename CfgValPairSimpleMembers<TOpt>::All,
        TExtraOpts...,
        comms::option::def::HasCustomRead,
        comms::option::def::HasCustomRefresh,
        comms::option::def::HasVersionDependentMembers<false>
    >
{
    using Base =
        comms::field::Bundle<
            cc_ublox::field::FieldBase<>,
            typename CfgValPairSimpleMembers<TOpt>::All,
            TExtraOpts...,
            comms::option::def::HasCustomRead,
            comms::option::def::HasCustomRefresh,
            comms::option::def::HasVersionDependentMembers<false>
        >;
public:
    /// @brief Allow access to internal fields.
    /// @details See definition of @b COMMS_FIELD_MEMBERS_NAMES macro
    ///     related to @b comms::field::Bundle class from COMMS library
    ///     for details.
    ///
    ///     The generated values, types and access functions are:
    ///     @li @b FieldIdx_key index, @b Field_key type and @b field_key() access function -
    ///         for cc_ublox::field::CfgValPairSimpleMembers::Key member field.
    ///     @li @b FieldIdx_val index, @b Field_val type and @b field_val() access function -
    ///         for cc_ublox::field::CfgValPairSimpleMembers::Val member field.
    COMMS_FIELD_MEMBERS_NAMES(
        key,
        val
    );

    /// @brief Name of the field.
    static const char* name()
    {
        return cc_ublox::field::CfgValPairSimpleCommon::name();
    }

    /// @brief Custom read functionality
    template <typename TIter>
    comms::ErrorStatus read(TIter& iter, std::size_t len)
    {
        auto es = Base::template readUntilAndUpdateLen<FieldIdx_val>(iter, len);
        if (es != comms::ErrorStatus::Success) {
            return es;
        }

        auto valId = getValueId();
        switch (valId) {
            case ValId_OneByteLsb: 
                field_val().initField_l();
                break;
            case ValId_OneByte:
                field_val().initField_u1();
                break;
            case ValId_TwoBytes:
                field_val().initField_u2();
                break;
            case ValId_FourBytes: 
                field_val().initField_u4();
                break;
            case ValId_EightBytes:
                field_val().initField_u8();
                break;
            default:
                return comms::ErrorStatus::InvalidMsgData;
        }

        return Base::template readFrom<FieldIdx_val>(iter, len);
    }

    /// @brief Custom refresh functionality
    bool refresh()
    {
        bool updated = Base::refresh();

        auto valId = getValueId();
        switch (valId) {
            case ValId_OneByteLsb: 
                if (field_val().currentField() != Field_val::FieldIdx_l) {
                    field_val().initField_l();
                    updated = true;
                }
                break;

            case ValId_OneByte:
                if (field_val().currentField() != Field_val::FieldIdx_u1) {
                    field_val().initField_u1();
                    updated = true;
                }
                break;

            case ValId_TwoBytes:
                if (field_val().currentField() != Field_val::FieldIdx_u2) {
                    field_val().initField_u2();
                    updated = true;
                }
                break;

            case ValId_FourBytes: 
                if (field_val().currentField() != Field_val::FieldIdx_u4) {
                    field_val().initField_u4();
                    updated = true;
                }
                break;

            case ValId_EightBytes:
                if (field_val().currentField() != Field_val::FieldIdx_u8) {
                    field_val().initField_u8();
                    updated = true;
                }
                break;

            default:
                if (field_val().currentField() < Field_val::FieldIdx_numOfValues) {
                    field_val().reset();
                    updated = true;
                }

                break;
        }

        return updated;
    }

    /// @brief Allow construction from other files, 
    ///     like members of CfgValPair.
    template <typename TFrom>
    static CfgValPairSimple from(const TFrom& f)
    {
        return comms::field_cast<CfgValPairSimple>(f);
    }

    /// @brief Allow casting to other fields, 
    ///     like members of CfgValPair.
    template <typename TTo>
    TTo to() const
    {
        return comms::field_cast<TTo>(*this);
    }

private:
    /// @brief Value ID
    enum ValId
    {
        ValId_OneByteLsb = 0x1,
        ValId_OneByte = 0x2,
        ValId_TwoBytes = 0x3,
        ValId_FourBytes = 0x4,
        ValId_EightBytes = 0x5,
        ValId_ValuesLimit
    };

    /// @brief Get the length of the value field
    ValId getValueId() const
    {
        return static_cast<ValId>(
            (static_cast<std::uint32_t>(field_key().value()) >> 28) & 0x7);    
    } 
};

} // namespace field

} // namespace cc_ublox
